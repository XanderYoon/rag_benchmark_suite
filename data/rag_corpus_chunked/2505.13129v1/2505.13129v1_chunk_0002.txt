been thoroughly applied in natural language-to-code translation First Workshop on Large Language Models For Generative Software Engineering (LLM4SE 2025) *Corresponding author. /envel⌢pe-⌢penkevinchenhao.li@tum.de (K. C. Li); v.zolfaghari@tum.de (V. Zolfaghari); nenad.petrovic@tum.de (N. Petrovic); f.pan@tum.de (F. Pan); k@tum.de (Prof. A. Knoll) © 2025 Copyright for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0). [7] [8], showing strong performance in converting natural language instructions into executable code in languages such as Python, Java, and SQL. Similarly, they can be adapted to translate natural language specifications into OCL rules [9] [10], reducing the manual effort required by human engineers. How- ever, LLMs often struggle with domain-specific knowledge [11], especially when dealing with complex specifications and extensive meta-models. A meta-model defines the structure and rules for how models are built in MBSE. It includes elements such as classes, associations, enumerations, and attributes. This is where RAG becomes essential. Large Language Models have a limited context window, making it challenging to include large and complex meta-models entirely in a prompt. RAG allows relevant parts of the meta-model to be retrieved and injected dynamically, helping the LLM generate precise rules even when the whole meta-model does not fit into the context window. Figure 1: Example meta-model from [9] Retrieval-Augmented Generation is an approach that enhances LLMs by integrating external knowl- edge retrieval into the generation process [12] [13]. This idea originated from the question answering domain [14]. Instead of relying solely on a model’s pre-trained knowledge, RAG retrieves relevant information from an external knowledge base and incorporates it into the model’s input before generat- ing the final output. This method has shown promise in improving accuracy, reducing hallucinations [15], and ensuring that generated content aligns with the domain [ 13]. Since OCL rules are tightly coupled with the underlying