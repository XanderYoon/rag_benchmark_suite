meta-model, where each class is represented as a node of the graph and associations are directed edges. The direction of the graph is dependent on the type of the association and its direction in the meta-model. PathOCL extracts all simple paths through the graph and ranks them based on their similarity to the natural language specification using either Jaccard or cosine similarity. For a natural language specification of an OCL constraint the approach extracts the UML elements using POS-tagging and then ranks all simple paths in the graph based on either the jaccard similarity or cosine similarity between the extracted elements and the node names along the path. The most relevant paths are then included in the prompt to help the LLM generate the correct OCL constraint. Although their approach aims to retrieve relevant classes in the face of limited context size, the dataset they use to evaluate their approach only consists of 15 UML models, where the largest model only contains 11 classes and 10 associations. Furthermore the PlantUML files of their dataset did not contain interfaces, enum, composition relations or aggregation relations. We evaluated the PathOCL method on the larger and harder dataset provided by [9]. One issue that was raised is the runtime on Table 4 Performance on subset with maximum length for meta-models Metric PathOCL (Jaccard k=1) Baseline SPLADE k=10 Mean CS 0.9251 0.9280 0.9328 Mean ED 5.3356 5.2775 4.9725 Table 5 PathOCL performance with Jaccard Similarity Metric Jaccard k=1 Jaccard k=3 Jaccard k=5 Mean CS 0.9251 0.9066 0.8986 Mean ED 5.3356 5.8805 6.2185 Table 6 PathOCL performance with Cosine Similarity Metric Cosine k=1 Cosine k=3 Cosine k=5 Mean CS 0.9204 0.8957 0.9030 Mean ED 5.4709 6.1700 6.0020 extremely large meta-models. Given the length of some of the meta-models, having upwards of 100 classes and 300