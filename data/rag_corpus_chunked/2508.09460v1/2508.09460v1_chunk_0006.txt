this diagnosis, it plans a targeted revision, such as generating new search queries to fill knowledge gaps or ignoring distracting evidence. While powerful, these methods reveal a critical limitation for graph exploration that their refinement loops operate are not at the path level. For instance, MetaRAGâ€™s â€œplanâ€ step can decide to trigger a completely new search with a revised query, but it lacks the fine-grained control to intervene within a single, ongoing graph traversal. It cannot perform fine-grained interventions, such as backtracking to a specific node on a flawed path and re-exploring from that point. Its mechanism is about replacing or adding entire evidence, not correcting a trajectory. This highlights an adaptation gap that existing metacognitive frameworks lack the graph-native ability to perform fine-grained diagnosis and correction. They cannot answer the crucial questions, â€œWhich specific step in my current path was the wrong turn? â€ and â€œHow can I correct my trajectory from that point?â€. This gap motivates our development of MetaKGRAG, which implements metacognitive cycles specifically for the unique challenges of structured knowl- edge retrieval, enabling path-aware refinement. 3 METAKGRAG FRAMEWORK Given a knowledge graph G = (E, R) and a natural language ques- tion ğ‘„, the KG-RAG task is to explore G to retrieve a relevant evidence subgraph S that provides sufficient context for an LLM to generate an accurate answer. The core of this process is the genera- tion of one or more evidence pathsğ‘ƒ = {(â„1, ğ‘Ÿ1, ğ‘¡1), . . . , (â„ğ‘›, ğ‘Ÿğ‘›, ğ‘¡ğ‘›)}, where each triplet (â„, ğ‘Ÿ, ğ‘¡) represents a head entity, relation, and tail entity respectively in the KG. 3.1 Framework Overview To simultaneously address the issues of relevance drift and incom- plete evidence in a way that respects the core challenge of path dependency that simple self-refinement methods cannot solve, we