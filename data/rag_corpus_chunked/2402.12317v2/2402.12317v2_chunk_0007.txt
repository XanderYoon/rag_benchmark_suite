problem description; M: the LLM to generate the code answer; Mq: the LLM to evolve queries; Mt: the LLM to generate test inputs; R: the retriever to output a list of relevant passages; K: the knowledge base; m: the maximum number of iterations; E: the compiler or interpreter to execute programs 2: Initialization: I = [], p = null. 3: for i = 0, . . . , mdo 4: if i = 0 then 5: qi ← n 6: else 7: qi ← Mq(n, pi−1, I, F i−1) ▷ Evolve query 8: end if 9: Kr ← R(qi, K) ▷ Retrieve relevant knowledge 10: pi ← M (n, Kr) ▷ Generate program 11: p ← pi 12: F i = E(pi, I) ▷ Execute and get feedback 13: if F i is sucess then 14: K ← K ∪ {pi} ▷ Evolve knowledge base 15: else 16: K ← K ∪ {(pi, F i)} ▷ Evolve knowledge base 17: end if 18: if i = 0 then 19: I ← Mt(n, pi) ▷ Generate test inputs 20: end if 21: if terminate condition is satisfied then 22: break 23: end if 24: end for 25: Return: p: output code. gramming language naturally align with the LLM generation objective and provide concrete exam- ples of inputs, outputs, and parameters. Further- more, they serve as a means to convey information about the programming language itself, providing crucial details such as bracket placement, utiliza- tion of special tokens, and other grammar. Before evaluation, we collect a set of code snippets ver- ified to be free of syntax errors (more details in Appendix D). Additionally, we also accumulate code solutions generated by LLMs. 2.2.2 Evolution The evolution of knowledge bases is primarily con- tributed by the execution feedback and code snip- pets. In