efficient querying of relationships between entities. Each agent utilizes the user’s query and the database schema to create the most effective query for that specific data source. This process is guided by a set of few-shot prompts [17] that provide the agent with relevant examples, ensuring that the query is syntactically correct and semantically meaningful. The modular approach to query generation allows the system to adapt to a wide range of data environments, making it suitable for complex, real-world applications. The query generated by each agent, Qgenerated, is derived from the user’s query, Quser, and the database schema, Sschema, through a function fagent, as expressed by the equation: Qgenerated = fagent(Quser, Sschema) This ensures that the generated query is perfectly aligned with the target database, which allows it to retrieve the correct data as requested by the user. 5.1.2 Query Execution Environment After the query is generated by the appropriate query generation agent, it is passed to theQuery Execution Environment. This environment serves as a central platform that connects the generated queries with the corresponding databases to retrieve the necessary data. The query execution environment plays a crucial role in ensuring that the queries are executed correctly and efficiently, managing communication between the system and different types of databases. The environment is equipped with database drivers that ensure compatibility with various types of databases. For example, relational databases like MySQL are accessed through JDBC drivers, which handle structured data in tables. For NoSQL databases such as MongoDB, there are MongoDB-specific drivers that handle document-based data, which can be more flexible and hierarchical. Similarly, graph databases like Neo4j require Neo4j drivers, which are specifically designed to query relationships between nodes in a graph structure. Depending on the type of database being queried, the correct driver is chosen to ensure smooth communication