Recent advancements, including knowledge distillation [74] and curricu- lum learning [113], continue to refine retrieval performance across diverse datasets. Re-ranking methods have also evolved alongside retrieval tech- niques to improve the ordering of retrieved documents. Traditional pointwise [114] and pairwise [11] approaches have given way to listwise methods like LambdaRank and ListNet [10, 55]. Deep neural models, including cross-encoders and transformer-based architec- tures, have demonstrated remarkable success in re-ranking tasks by capturing complex interactions between queries and documents. Zero-shot and in-context re-ranking with large language models (LLMs), such as GPT-4 [5] and RankT5 [115], now enable effective ranking adjustments without task-specific training. Retrieval-Augmented Generation (RAG) has emerged as a pow- erful paradigm for enhancing generative models in knowledge- intensive tasks [51]. By retrieving relevant documents and inte- grating them into the generative process, RAG systems improve factual accuracy and reduce hallucinations. Techniques like self- consistency [101] and noise filtering [25] have been proposed to further improve the reliability of RAG outputs. However, the effec- tiveness of these systems heavily depends on the quality of retrieved and re-ranked documents, highlighting the need for robust retrieval frameworks. In response to the growing complexity of IR, re-ranking, and RAG tasks, several frameworks have been introduced. Rerankers [19] provides a lightweight Python interface for common re-ranking models, while RankLLM focuses on listwise re-ranking with LLMs. Other frameworks like FlashRAG [39] and AutoRAG [46] offer mod- ular components for RAG experimentation, though they often lack support for diverse datasets and advanced retriever configurations. Tools such as LangChain [12], LlamaIndex [54], and DSPy [44] fur- ther contribute to the ecosystem by simplifying model integration and workflow design. A comparison of retrieval, re-ranking, and RAG toolkits is presented in Table 1, highlighting the advantages of Rankify in dataset diversity, retriever and re-ranker support, and modularity. 3 Rankify