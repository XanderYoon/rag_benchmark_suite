document containing an ID field with arbitrary fields carrying its content.RoutIRloads each JSONL collection file and builds a memory offset lookup table to efficiently look up the document when serving the content. Such lookup tables allowRoutIRrandom access the collection file based on docu- ment IDs without reading the file sequentially or loading the entire collection into memory. RoutIRprovides several built-in Engine types that can be used to serve models with common architectures such as dense bi-encoders with FAISS indices, multi-vector dense retrieval with PLAID-X [48], and learned-sparse retrieval 10 E. Yang et al. 1class P y s e r i n i B M 2 5 ( Engine ) : 2def __init__ ( self , name : str = None , config = None , ** kwargs ) : 3super () . __init__ ( name , config , ** kwargs ) 4self . searcher = L u c e n e S e a r c h e r ( self . i n d e x _ p a t h ) 5self . searcher . set_bm25 (0.9 , 0.4) 6 7async def s e a r c h _ b a t c h ( self , queries , limit =20) : 8return [ 9{ docobj . docid : docobj . score 10for docobj in self . searcher . search ( query , k = lm ) } 11for query , lm in zip ( queries , limit ) 12] Fig. 4.Example code snippet for integrating Pyserini withRoutIR. This example can be extended with more flexible parameter configuration or even allowing the endpoint users to specify the retrieval model. Full example can be found athttps://github. com/hltcoe/routir/blob/main/examples/pyserini_extension.py. models with Anserini [50]. These Engines are implemented based on anEngine Python abstract class that ensures a common interface. These Engine types