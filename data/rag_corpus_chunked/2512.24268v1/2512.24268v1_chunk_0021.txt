k ). This expression is derived by subtracting the number of fragment mixes that contain no poisoned fragment from the total number of possible mixes. A sufficient condition for robustness in the naive baseline is: (N k ) − ( N−n p k ) < 1 2 (N k ). 11 RAGPart & RAGMask: Retrieval-Stage Defenses Against Corpus Poisoning in Retrieval-Augmented Generation RAGPart.In contrast, RAGPart computes embeddings for individual fragments before mixing, and aggre- gates them via mean pooling. This reduces the influence of any single poisoned fragment. Suppose that a mix is considered poisoned only if it containsat least twopoisoned fragments. Then, the number of poisoned mixes is: x= (N k ) − ( N−n p k ) −n p( N−n p k−1 ). Here: •( N−n p k )counts the number of clean mixes (no poisoned fragments), •n p(N−n p k−1 )counts the number of mixes containing exactly one poisoned fragment, and their sum represents the number of mixes that are not adversarial for RAGPart. Thus, a sufficient condition for robustness in RAGPart is: (N k ) − ( N−n p k ) −n p( N−n p k−1 ) < 1 2 (N k ). In Tables 2 and 3, we show the values ofN and k for which the sufficient condition for robustness holds under the naive baseline and RAGPart, respectively, fornp =2 . Similar results fornp =3 are presented in Tables 4 and 5. We observe that RAGPart yields significantly more combinations ofN and k that satisfy the robustness condition compared to the naive baseline. Overall, we recommend using lower values ofN and higher values ofkin practice to minimize performance degradation. Table 2:Sufficient condition for robustness under the naive baseline withnp =2 . A green checkmark (✓) indicates that the condition holds for the given pair