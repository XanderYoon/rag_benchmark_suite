simplicity. Under this setting, as long as thetotal number of poisoned mixesacross allna adversarial documents is less than na na+1 (N k ), the least frequent clean document will still appear more often than any individual poisoned document in the final embedding matrix. This condition ensures robustness of top-p retrieval: each poisoned document can contribute at most 1 na+1 (N k )mixes, while the least frequent clean document will contribute more than 1 na+1 (N k ). Thus, clean documents will dominate in frequency, and the top-p results will exclude all poisoned ones. Accordingly, the sufficient conditions for robustness are: Naive baseline: (N k ) − ( N−n p k ) < 1 na +1 (N k ) RAGPart: (N k ) − ( N−n p k ) −n p( N−n p k−1 ) < 1 na +1 (N k ) 14 RAGPart & RAGMask: Retrieval-Stage Defenses Against Corpus Poisoning in Retrieval-Augmented Generation 6.2. Computational Complexity: RAGPart vs. Naive Baseline In this section, we analyze the computational complexity of computing the final document embeddings prior to similarity comparison with the query. We compare the naive baseline and RAGPart from a theoretical perspective. Assume that running the embedding model on a fraction1 N of a document requiresR FLOPs. Then, running it on a fractionk N (i.e., a mix ofkfragments) requiresk×RFLOPs. Naive Baseline.For each document, there are( N k )possible mixes of fragments. The embedding model is applied to each of thesek-length mixes, so the total computational cost is: FLOPsnaive =D× (N k ) ×(k×R) RAGPart.In RAGPart, the embedding model is applied once to each of theN individual fragments per document, for a total of: FLOPsembedding =D×N×R Then, for each of the(N k ) combinations, we compute the mean ofk precomputed embeddings, each of dimensionn e, costingk×n e FLOPs per mix. Therefore,