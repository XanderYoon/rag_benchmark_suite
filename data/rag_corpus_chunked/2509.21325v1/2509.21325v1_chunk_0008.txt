and uses a fast LWE-based PIR scheme to privately download the entire cluster for local re-ranking. Client-Side Query Formulation. The user’s client software first computes the embedding for the query. It then compares this embedding to the public centroids of the n clusters and identifies the index i of the closest cluster. Following this, the client constructs an n-dimensional one-hot vector with a 1 at the identified index i and encrypts it using a fast, lattice-based scheme. This encrypted query is the only information sent to the server. Server-Side Private Computation. The server receives the encrypted query vector. It then performs a highly efficient homomorphic matrix-vector multiplication between its public m × n database and the user’s encrypted n × 1 query vector. Due to the properties of homomorphic encryption, this results in an m × 1 encrypted vector that contains the desired document chunks from cluster i. This encrypted result is then sent back to the client. Client-Side Finalization. The client decrypts the response from the server to obtain the plaintext documents of the target cluster. It then performs a final local re-ranking of these docu- ments to identify and present the top-K most relevant results to the user. 4 Evaluation To rigorously evaluate PIR-RAG, we compare it against our own implementations of two pow- erful baseline architectures, representing the state-of-the-art in graph-based and private-scoring paradigms. 4.1 Experimental Setup • Datasets: We use the MS MARCO document collection for quality evaluation and the SIFT1M dataset for scalability analysis. • Baselines: We implemented two baseline systems for direct comparison: 5 1. Graph-PIR: An architecture inspired by systems like PACMANN [10]. It constructs a k-NN similarity graph over document embeddings. Retrieval is performed via a private, multi-step graph traversal using the same LHE-based PIR primitive to fetch neighbors at each hop.