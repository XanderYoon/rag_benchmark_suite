retrieving relevant queries, (2) expanding to neighboring queries, (3) collecting and ranking associated chunks, and (4) generating responses. Step 1: Retrieving Relevant Queries.Given a user query qu, we first compute its similarity with graph queriesQ g =SN i=1 Qα g,i. The similarity is defined as: s(qu, q) =sim(q u, q) +ϵ,∀q∈ Q g, where sim(·,·) denotes cosine similarity, and ϵ= 1 . To construct the set of retrieved queries, we apply both a similarity threshold γ∈[0,2] to ensure relevance and a maximum node constraint n to control graph size. Qr =  q∈ Q g |s(q u, q)≥γ ,|Q r| ≤n. 5 Step 2: Expanding to Neighboring Queries.For each retrieved query q∈ Q r, we collect its h-hop neighbors from the query-level graph. Formally, the one-hop neighbors are defined as: H1(q) ={q ′ |(q, q ′)∈E intra}. For h >1 , the h-hop neighbors are obtained by expanding the (h−1)-hop set: Hn(q) = [ q′∈Hn−1(q) H1(q′). The final query set is then the union of retrieved queries and theirh-hop neighborhoods: Q∗ =Q r ∪ [ q∈Qr h[ i=1 Hi(q). Step 3: Collecting and Ranking Associated Chunks.Each query q∈ Q ∗ is linked to its originating chunk(s) via query–chunk membership relations: C∗ ={c i ∈ C |(q, c i)∈E inter, q∈ Q ∗}. To select the most relevant chunks, we compute a relevance score for each chunkc∈ C ∗: s(c) = 1 |Qc| X q∈Qc sim qu, q  , where Qc denotes the subset of queries in Q∗ associated with chunk c. Chunks are ranked by s(c), and the top-Kare retained: Ctop-K =Top-K{c∈ C ∗ |s(c)}. Step 4: Generating Responses.Finally, the answer is generated by conditioning the LLM on the user queryq u and the top-Kselected chunksC top-K: a=LLM qu | Ctop-K  . The Query-Centric Graph Retrieval & Generation