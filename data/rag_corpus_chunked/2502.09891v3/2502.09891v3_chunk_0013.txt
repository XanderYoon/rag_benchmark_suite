to q, then x is added to the expansion queue. Algorithm 2: Hierarchical search input : H = (G, Linter), q, k. 1 s ← a random node in the highest layer L; 2 R ← ∅; 3 for i ← L, · · · , 0 do 4 Ri ← SearchLayer (Gl = (Vl, El), q, s, k); 5 R ← R ∪ Ri; 6 c ← get the nearest node from Ri; 7 s ← find the node in layer i − 1 via the inter-layer links of c; 8 return R; 9 Procedure SearchLayer(Gi = (Vi, Ei), q, s, k): 10 V ← {s}, K ← {s}, Q ← initialize a queue containing s; 11 while |K| > 0 do 12 c ← nearest node in Q; 13 f ← furthest node in K; 14 if d(c, q) > d(f, q) then break ; 15 for each neighbor x ∈ N (c) in Gi do 16 if x ∈ V then continue; 17 V ← V ∪ {x}; 18 f ← furthest node in K; 19 if d(x, q) < d(f, q) or |K| < k then 20 Q ← Q ∪ {x}, K ← K ∪ {x}; 21 if |K| > k then remove f from K; 22 return K; • Dynamic Nearest Neighbor Set K: Nodes added to C are used to update K, ensuring that it maintains no more than k elements, where k is the number of query results. • Stopping Condition: The traversal terminates if a node x expanded from Q satisfies d(n, q) > d(n, f), where f is the furthest node in K from the query point q. After completing the hierarchical search and obtaining the ACs and entities from each layer, we further extract their associated textual information. In