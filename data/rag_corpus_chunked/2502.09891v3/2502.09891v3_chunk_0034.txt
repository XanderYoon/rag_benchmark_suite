not have a inter-layer link to the layer i. • The distance from node cj to node x is smaller than the distance from cj to its previous nearest neighbor x′, i.e., d(cj, x) < d(cj, x′). After all nodes at layer i (i < L ) have been inserted, we check each node at layer i + 1 to ensure it has a inter-layer link, confirming the traverse from the higher layer to the lower layer. Algorithm 3: C-HNSW construction input : The Hierarchical community HC, KG G(V, E), maximum number of connections for each node M. 1 H ← ∅ ; 2 V ← {HC ∪ V } // Get all nodes of each layer. 3 for each layer l ← L · · · 0 do 4 for each node v ∈ Vl do 5 if l ̸= L then 6 R ← SearchLayer(Gl = (Vl, El), q, s, 1); 7 c ← get the nearest node from R; 8 s ← node in layer l − 1 via c’s inter-layer link; 9 if s is null or d(c, s) > d(c, v) then 10 update v as c’s inter-layer link 11 if l = L or s is null then s ← random node in layer l; 12 R ← SearchLayer(Gl = (Vl, El), q, s, M); 13 add edges between v and R, update El; 14 H ← H ∪ Gl = (Vl, El) 15 return H; Complexity analysis of ArchRAG We now analyze the complexity of our ArchRAG approach. Since the token cost is more important in the era of LLM, we replace the space complexity with the token cost. The offline indexing process of ArchRAG includes the KG construction, hierarchical clustering, and C-HNSW con- struction. The time complexity and token usage are as