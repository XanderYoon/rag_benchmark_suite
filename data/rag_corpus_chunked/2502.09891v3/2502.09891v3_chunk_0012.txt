otherwise arise from repeatedly searching from the top layer, thereby en- abling efficient multi-layer retrieval. Algorithm 2 illustrates hierarchical search. Given the C- HNSW H, query point q, and the numberk of nearest neigh- bors to retrieve at each layer, the hierarchical search algo- rithm can be implemented by the following iterative process: 1. Start from a random node at the highest layer L, which serves as the starting node for layer L (line 1). 2. For each layer i from the top layer L down to layer 0, the algorithm begins at the starting node and performs a greedy traversal (i.e., the SearchLayer procedure) to find the set Ri of the k nearest neighbors of q. The set Ri is then merged into the final result set R (lines 4–5). 3. The closest neighbor c of q is then obtained from Ri, and the algorithm proceeds to the next layer by traversing the inter-layer link of c, using it as the starting node for the subsequent search (lines 6–7). Specifically, the greedy traversal strategy compares the distance between the query point and the visited nodes dur- ing the search process. It maintains a candidate expansion queue Q and a dynamic nearest neighbor set K containing k elements, along with a stopping condition: • Expansion Queue Q: For each neighbor x of a visited node, if d(x, q) < d (f, q), where f is the furthest node from R to q, then x is added to the expansion queue. Algorithm 2: Hierarchical search input : H = (G, Linter), q, k. 1 s ← a random node in the highest layer L; 2 R ← ∅; 3 for i ← L, · · · , 0 do 4 Ri ← SearchLayer (Gl = (Vl, El), q, s, k); 5