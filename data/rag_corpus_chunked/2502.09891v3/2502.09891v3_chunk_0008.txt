and stopping condition T , we perform the following steps in each iteration: (1) augmenting the graph (line 3); (2) computing the edge weights (lines 4-5); (3) clus- tering the augmented graph (line 6); (4) generating a sum- mary for each community using LLM (line 7); and (5) build- ing a new attributed graph where each node denotes an AC and two nodes are linked if their community members are connected (line 9). We repeat the iterations until the stop- ping condition T (such as insufficient nodes or reaching the specified level limit) is met. Since each iteration corresponds to one layer, all the ACs HC can be organized into a multi- layer hierarchical tree structure, denoted by ∆, where each community in one layer includes multiple communities in the next layer. Appendix also provides more details. C-HNSW index. Given a query, to efficiently identify the most relevant information from each layer of the hierarchical tree ∆, a naive method is to build a vector database for the ACs in each layer, which is costly in both time and space. To tackle this issue, we propose to build a single hierar- Algorithm 1: LLM-based hierarchical clustering input : G(V, E), Aug, GCluster, T 1 T ← False, HC ← ∅; 2 repeat 3 G′(V, E ′) ← Aug(G(V, E)); 4 for each e′ = (u, v) ∈ E′ do 5 update the weight of e′ as 1 − cos(zu, zv); 6 C ← GCluster(G′(V, E ′)); 7 for each c ∈ C do generate summary of c by LLM ; 8 HC ← HC ∪ C; 9 G(V, E) ← build a new graph using C and E′; // update T according to G(V, E); 10 until T =True; 11 return HC ; chical index for all the communities. Recall