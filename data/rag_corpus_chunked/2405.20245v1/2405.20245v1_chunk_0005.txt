for each line item, but only for the words in the chunk assigned to the line item. The challenge is how to divide the page. The naive dynamic programming approach with 2D states (line item index, page y) has complexity Algorithm 1 Bounding Box Backcalculation Heuristic Inputs: y lower- & upperbound, predicted key-value map, and OCR data Outputs: Matching score, key to bounding box mapping 1: score ← 0; key bbox map ← {} 2: for all (key, value) pair in the key-value map do 3: m words ← The longest contiguous list of words matching value whose bounding boxes lie within the y lowerbound and upperbound 4: m bboxes ← Bounding boxes of m words 5: key bbox map[key] ← union(m bboxes) 6: score ← score + similarity(concat(m words)), value) 7: return (score, key bbox map) O(M N2·O(Algo 1)) where M is the number of line items and N is the page height. We can optimize this by down-scaling the page. In production we use N = 128. A further optimization takes advantage of the monotonicity of Algorithm 1: the matching score is non-increasing as we increase the y lower bound and decrease the y upper bound. Therefore, we can use the Divide-and-Conquer optimization for dynamic program- ming problems to speed this up to O(M N log N ·O(Algo 1 )). Finally, we employ binary search to find the largest y lower- bound for the first and the smallest y upperbound for the last line item to tighten the bounds. III. G ENERAL LINE ITEMS RECOGNITION METRIC The goal of LIR is to extract information into an ordered list of line items where each line item corresponds to a row in a table and is formatted into column key-value pairs. In this section, we will derive a new metric