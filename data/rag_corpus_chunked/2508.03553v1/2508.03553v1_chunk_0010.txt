formula: DF usion = n[ i=1 Ai(Di) (2) where Ai ∈ { Adastru, Adasemi-s, Adaunstru}, representing the adapter parsing functions for structured data, semi- structured data, and unstructured data, respectively. Di ∈ {Dstru, Dsemi-s, Dunstru} represents the original datasets of struc- tured data, semi-structured data, and unstructured data, respec- tively. Through the parsed data DFusion = {Eq, Rq}, we further extracts key information and links it to the knowledge graph. The knowledge construction process involves three key phases implemented through the OpenSPG framework 1 [26], [32], in which we use the Custom Prompt module2 to integrate LLM-based knowledge extraction. For entity recognition, we utilize the ner.py prompts within the kag/builder/prompt/default directory. We first define relevant entity types in the schema. Then, by adjusting the example.input and example.output in the ner.py prompts, we guide the LLM-based SchemaFreeExtractor to identify entities accurately. In relationship extraction, the triple.py prompts play a crucial role. We define relationships in the schema and use the triple prompt in the SchemaFreeExtractor. The instruction in triple.py ensures that the extracted Subject- Predicate-Object(SPO) triples are related to the entities in the entity list, enabling effective relationship extraction. Regarding attribute extraction, we rely on the entity stan- dardization prompts in std.py. After entity recognition, the std prompt in the SchemaFreeExtractor standardizes the entities and helps in extracting their attributes. We mod- ify the example.input, example.named entities, and exam- ple.output in std.py according to our data characteristics to optimize the attribute extraction process. Through these steps of customizing and applying OpenSPG’s prompts, we achieve efficient knowledge extraction. 1https://github.com/OpenSPG/openspg 2https://openspg.yuque.com/ Fig. 4: Example of multi-source line graph transformation The following formula describes the data extraction process: KB = X Di ({e1, e2, ..., em} G {r1, r2, ..., rn}) (3) C. Homologous Subgraph Matching After the preliminary extraction of information, the next