describe a knowledge Synchronisation (Sync) process to locate initial nodes for graph expan- sion. We first employ an LLM to read C′ q (see Appendix K.2) and summarise knowledge triples that can support answering the current query q: T′ q = read C′ q, q  . (1) T′ q is a collection of triples to which we refer as proximal triples. Initial nodes Tq for graph expansion are identified by linking each triple in T′ q to a triple in T, using the tripleLink function: Tq =  ti|ti = tripleLink(t′ i) ∀t′ i ∈ T′ q . (2) The implementation oftripleLink can vary. How- ever, in this paper we consider it to be simply retrieving the most similar triple from T using h1 base (t′ i, T) ∀t′ i ∈ T′ q. 4.2 Diverse Triple Beam Search We borrow the idea of constructing reasoning triple chains (Fang et al., 2024) for expanding the graph, Algorithm 1 Diverse Triple Beam Search Input: q: query b: beam size l: maximum length score(·, ·): scoring function {t1, t2, . . . , tn}: initial triples γ: hyperparameter for diversity 1: B0 ← [ ] 2: for t ∈ {t1, t2, ..., tn} do 3: s ← score(q, [t]) 4: B0.add(⟨s, [t]⟩) 5: B0 ← top(B0, b) 6: for i ∈ {1, . . . , l− 1} do 7: B ← [ ] 8: for ⟨s, T ⟩ ∈ Bi−1 do 9: V ← [ ] 10: for t ∈ get_neighbours(T.last()) do 11: if exists(t, Bi−1) then 12: continue 13: s′ ← s+score(q, T ◦t) # concat 14: V.add(⟨s′, T ◦ t⟩) 15: sort(V, descending) 16: for n ∈ {0, . . . , V.length() − 1} do 17: ⟨s′, T ◦ t⟩ ← V [n] 18: s′ ← s′ ×