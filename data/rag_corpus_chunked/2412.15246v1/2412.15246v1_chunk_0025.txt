offload by writing into a doorbell register. The offload context and doorbells are communicated through memory-mapped regions calledcontext buffersto the IKS as shown in Figure 5a. Anoffload context includes query vectors, vector dimensions, and the base address of the first embedding vector stored in each LPDDR5X package. The host process then uses umwait() to block on the doorbell regis- ter (shared between IKS and the host and kept coherent via the CXL.cache protocol) to implement efficient notification between the paused CPU process and near-memory acceler- ators [105]. As IKS uses a scale-out near-memory processing archi- tecture (§5.1), the embedding vectors are distributed across different near-memory accelerators’ local DRAM. Therefore, after all the near-memory accelerators complete the offload, the CPU process waiting on umwait() will be notified and execute an aggregation routine to construct a single top-K list. This top-K list is then used to retrieve the actual top-K docu- ments from the host memory. The CPU will locate documents based on the physical addresses of the top-K embedding vec- tors, as the addresses of the embedding vectors stored in IKS are known a priori. 5.3 Cache Coherent Interface IKS leverages the cache-coherent interconnect in CXL.cache to implement an efficient interface between near-memory accelerators and host processes through shared memory. Fig- ure 6 illustrates the transactions through the CXL.cache in- terface between the host and IKS to initiate and conclude an offload. The host process writes theoffload context to the pre- defined context buffer address range shared between NMAs and the host CPU (step 1). Note that the context buffer is cacheable, and the CPU uses temporal writes to populate the Description1CPU writes the parameters and queries to the corresponding NMA context buffers2CPU writes into the NMA context doorbell and pauses on the doorbell updates using umwait()3NMA polling on the doorbells