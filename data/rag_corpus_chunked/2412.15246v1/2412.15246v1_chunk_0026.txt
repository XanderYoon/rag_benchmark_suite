defined context buffer address range shared between NMAs and the host CPU (step 1). Note that the context buffer is cacheable, and the CPU uses temporal writes to populate the Description1CPU writes the parameters and queries to the corresponding NMA context buffers2CPU writes into the NMA context doorbell and pauses on the doorbell updates using umwait()3NMA polling on the doorbells leads to cache coherency activity, moving the doorbell to IKS4NMA gets informed of the doorbell update5NMA starting to access the parameters and the queries6Cache coherency activity moves parameters and queries from the Host to the IKS7Offload starts and NMAs perform similarity search in parallel8NMA write partial top-K lists to the context output buffers9NMA updates the context doorbell10Doorbell cacheline moves from the IKS to the Host cache11CPU resumes and reads the context output buffers IKSHostCXL cacheNMAHost cacheCPU12 1187 3 10 Polling456 9 Fig. 6. CPU-IKS interface through cache coherent CXL interconnect. buffers. Next, the host process writes into a doorbell regis- ter, which is mapped to a cache line shared by NMAs. NMAs poll on the doorbell register, and as soon as there is a change, the offload starts (step 4). Once the host updates the doorbell register, it callsumwait() to monitor the register for changes from the IKS side. Before computation in the NMA can start, the NMA reads the offload context from the IKS cache (step 5) and the context written by the host is moved to NMAâ€™s scratchpad. Once the NMA computation is complete, the NMA updates the context buffers with the partial list of similarity scores and physical addresses of the corresponding embedding vectors. Lastly, the NMA writes into the doorbell register, and the host gets notified of the completion of the offload through theumwait() mechanism (step 11). Our experimental results on a two-socket Sapphire Rapids CPU