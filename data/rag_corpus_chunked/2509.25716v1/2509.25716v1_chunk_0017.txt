with various exclusions. The results consistently showed that removing the last 1-2 lines before the API invocation leads to significant performance degradation in both Top-K accuracy and Mean Reciprocal Rank (MRR), regardless of the overall context length. This finding, as illustrated in 6 suggests that while broader context provides some benefit, the imme- diate preceding lines contain disproportionately valuable information for predicting the appropriate API. This aligns with the intuitive understanding that developers typically write code in a sequential manner, where the most recent lines provide the strongest signals about the intended functionality and API requirements. Figure 6: Effect of Code Proximity on Performance B. Knowledge Graph Analysis An analysis of the Script Include (SI) Knowledge Graph on our developer instance reveals several key insights. The instance contains 2,516 global SIs and 1,744 non-global SIs. By focusing the search on non-global packages and scopes, the search space is reduced by approximately 59%. This is a significant improvement, and the search can be narrowed even further. Approximately 97% of non-global SIs follow a one-to-one mapping, meaning they are used in only a single package and scope. As a result, many package-scope pairs map to a single SI, often eliminating the need for a deeper search within those contexts. C. Ablation Study on Model Selection As a preliminary step, we conducted an ablation study on an older version of our dataset to select a foundational embedding model. This initial evaluation compared several models, most notably linq-embed-mistral against Jina, which is a widely used embedding model for code retrieval. The study was performed without any advanced indexing or retrieval techniques to purely assess the baseline performance of the models. The results, shown in Figure 7, demonstrated that linq-embed-mistral performed significantly better than Jina. Based on these preliminary findings, we chose it for all